# 并发多线程&死锁

张三：站在北京等李四，不挪窝；
李四：站在北京等张三，不挪窝。

C++：比如有两把锁（死锁这个问题，至少有两个锁头，即两个互斥量才能产生）。

两个线程A和B：

1. 线程A执行的时候，这个线程先锁金锁，把金锁lock()成功了，然后去lock银锁；
2. 线程B执行了，这个线程先锁银锁，因为银锁还没有被锁，所以银锁会lock成功，线程B要去lock金锁；
3. 此时此刻，死锁就产生了；
4. 线程A因为拿不到银锁头，流程走不下去。
5. 线程B因为拿不到金锁头，流程走不下去。

```cpp
void inMsgRecvQueue()
{
    for (int i = 0;i < 100000;++i)
    {
        cout << "inMsgRecvQueue()执行，插入一个元素" << i << endl;
        my_mutex1.lock(); // 线程A拿到金锁
        my_mutex2.lock(); // 线程A尝试拿银锁，被线程B拿了，所以拿不到，卡在这
        msgRecvQueue.push_back(i);
        my_mutex2.unlock();
        my_mutex1.unlock();
    }
}

bool outMsgLULProc(int& command)
{
    my_mutex2.lock(); // 线程B上来拿到银锁
    my_mutex1.lock(); // 线程B尝试拿金锁，被线程A拿了，所以拿不到，卡在这
    if (!msgRecvQueue.empty())
    {
        command = msgRecvQueue.front();
        msgRecvQueue.pop_front();
        my_mutex1.unlock();
        my_mutex2.unlock();
        return true;
    }
    my_mutex1.unlock();
    my_mutex2.unlock(); 
    return false; 
}
```

**死锁的解决方案：只要保证两个互斥量上锁的顺序保持一致就不会死锁。**

### 参考链接

[(19条消息) c++11中的lock_guard和unique_lock使用浅析_guotianqing的博客-CSDN博客_lock_guard和unique_lock](https://blog.csdn.net/guotianqing/article/details/104002449)

[(19条消息) C++11多线程 unique_lock详解_u012507022的博客-CSDN博客_c++ unique_lock](https://blog.csdn.net/u012507022/article/details/85909567?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)

[(19条消息) C++并发与多线程（4）——unique_lock详解_Mount256的博客-CSDN博客_c++ unique_lock](https://blog.csdn.net/baidu_39514357/article/details/113903152)

[(19条消息) 多线程共享数据的保护+互斥量概念、用法、死锁演示及解决详解(std::lock()、std::adopt_lock)_HITXJ的博客-CSDN博客_adopt_lock](https://blog.csdn.net/HITXJ/article/details/108439190?spm=1001.2101.3001.6650.1&depth_1-utm_relevant_index=2)

[(18条消息) c++11多线程编程同步——使用条件变量condition variable_guotianqing的博客-CSDN博客_c++11 多线程 条件变量](https://blog.csdn.net/guotianqing/article/details/104017649)